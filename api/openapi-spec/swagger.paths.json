{
  "/apis": {
    "get": {
      "consumes": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "description": "get available API versions",
      "operationId": "getAPIVersions",
      "produces": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "apis"
      ]
    }
  },
  "/apis/management.loft.sh": {
    "get": {
      "consumes": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "description": "get information of a group",
      "operationId": "getManagementLoftShAPIGroup",
      "produces": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh"
      ]
    }
  },
  "/apis/management.loft.sh/v1": {
    "get": {
      "consumes": [
        "application/json",
        "application/yaml"
      ],
      "description": "get available resources",
      "operationId": "getManagementLoftShV1APIResources",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ]
    }
  },
  "/apis/management.loft.sh/v1/agentauditevents": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create an AgentAuditEvent",
      "operationId": "createManagementLoftShV1AgentAuditEvent",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AgentAuditEvent"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AgentAuditEvent"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AgentAuditEvent"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AgentAuditEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "AgentAuditEvent",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/announcements": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind Announcement",
      "operationId": "listManagementLoftShV1Announcement",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AnnouncementList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Announcement",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/apps": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of App",
      "operationId": "deleteManagementLoftShV1CollectionApp",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind App",
      "operationId": "listManagementLoftShV1App",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.AppList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create an App",
      "operationId": "createManagementLoftShV1App",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/apps/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete an App",
      "operationId": "deleteManagementLoftShV1App",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified App",
      "operationId": "readManagementLoftShV1App",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the App",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified App",
      "operationId": "patchManagementLoftShV1App",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified App",
      "operationId": "replaceManagementLoftShV1App",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.App"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusteraccesses": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of ClusterAccess",
      "operationId": "deleteManagementLoftShV1CollectionClusterAccess",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind ClusterAccess",
      "operationId": "listManagementLoftShV1ClusterAccess",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccessList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a ClusterAccess",
      "operationId": "createManagementLoftShV1ClusterAccess",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusteraccesses/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a ClusterAccess",
      "operationId": "deleteManagementLoftShV1ClusterAccess",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified ClusterAccess",
      "operationId": "readManagementLoftShV1ClusterAccess",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterAccess",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified ClusterAccess",
      "operationId": "patchManagementLoftShV1ClusterAccess",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified ClusterAccess",
      "operationId": "replaceManagementLoftShV1ClusterAccess",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAccess"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusterconnect": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a ClusterConnect",
      "operationId": "createManagementLoftShV1ClusterConnect",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterConnect"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterConnect"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterConnect"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterConnect"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterConnect",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusterroletemplates": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of ClusterRoleTemplate",
      "operationId": "deleteManagementLoftShV1CollectionClusterRoleTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind ClusterRoleTemplate",
      "operationId": "listManagementLoftShV1ClusterRoleTemplate",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplateList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a ClusterRoleTemplate",
      "operationId": "createManagementLoftShV1ClusterRoleTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusterroletemplates/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a ClusterRoleTemplate",
      "operationId": "deleteManagementLoftShV1ClusterRoleTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified ClusterRoleTemplate",
      "operationId": "readManagementLoftShV1ClusterRoleTemplate",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterRoleTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified ClusterRoleTemplate",
      "operationId": "patchManagementLoftShV1ClusterRoleTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified ClusterRoleTemplate",
      "operationId": "replaceManagementLoftShV1ClusterRoleTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterRoleTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of Cluster",
      "operationId": "deleteManagementLoftShV1CollectionCluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind Cluster",
      "operationId": "listManagementLoftShV1Cluster",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Cluster",
      "operationId": "createManagementLoftShV1Cluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a Cluster",
      "operationId": "deleteManagementLoftShV1Cluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Cluster",
      "operationId": "readManagementLoftShV1Cluster",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Cluster",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified Cluster",
      "operationId": "patchManagementLoftShV1Cluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified Cluster",
      "operationId": "replaceManagementLoftShV1Cluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Cluster"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters/{name}/agentconfig": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read agentconfig of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterAgentconfig",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterAgentConfig"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAgentConfig",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterAgentConfig",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/clusters/{name}/charts": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read charts of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterCharts",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterCharts"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterCharts",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterCharts",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create charts of a Cluster",
      "operationId": "createManagementLoftShV1ClusterCharts",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterCharts"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterCharts"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterCharts"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterCharts"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterCharts",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters/{name}/domain": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read domain of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterDomain",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterDomain"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterDomain",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterDomain",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create domain of a Cluster",
      "operationId": "createManagementLoftShV1ClusterDomain",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterDomain"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterDomain"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterDomain"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterDomain"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterDomain",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters/{name}/memberaccess": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read memberaccess of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterMemberaccess",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterMemberAccess"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterMemberAccess",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterMemberAccess",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/clusters/{name}/members": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read members of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterMembers",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterMembers"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterMembers",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterMembers",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/clusters/{name}/reset": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ClusterReset",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create reset of a Cluster",
      "operationId": "createManagementLoftShV1ClusterReset",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterReset"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterReset"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterReset"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterReset"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterReset",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/clusters/{name}/virtualclusterdefaults": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read virtualclusterdefaults of the specified Cluster",
      "operationId": "readManagementLoftShV1ClusterVirtualclusterdefaults",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ClusterVirtualClusterDefaults"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterVirtualClusterDefaults",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ClusterVirtualClusterDefaults",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/configs": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Config",
      "operationId": "createManagementLoftShV1Config",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Config"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Config"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Config"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Config"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Config",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/configs/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Config",
      "operationId": "readManagementLoftShV1Config",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Config"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Config",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Config",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/devpodworkspaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind DevPodWorkspaceInstance",
      "operationId": "listManagementLoftShV1DevPodWorkspaceInstanceForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/devpodworkspacetemplates": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of DevPodWorkspaceTemplate",
      "operationId": "deleteManagementLoftShV1CollectionDevPodWorkspaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind DevPodWorkspaceTemplate",
      "operationId": "listManagementLoftShV1DevPodWorkspaceTemplate",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplateList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a DevPodWorkspaceTemplate",
      "operationId": "createManagementLoftShV1DevPodWorkspaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/devpodworkspacetemplates/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a DevPodWorkspaceTemplate",
      "operationId": "deleteManagementLoftShV1DevPodWorkspaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified DevPodWorkspaceTemplate",
      "operationId": "readManagementLoftShV1DevPodWorkspaceTemplate",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified DevPodWorkspaceTemplate",
      "operationId": "patchManagementLoftShV1DevPodWorkspaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified DevPodWorkspaceTemplate",
      "operationId": "replaceManagementLoftShV1DevPodWorkspaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/directclusterendpointtokens": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a DirectClusterEndpointToken",
      "operationId": "createManagementLoftShV1DirectClusterEndpointToken",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DirectClusterEndpointToken"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DirectClusterEndpointToken"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DirectClusterEndpointToken"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DirectClusterEndpointToken"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DirectClusterEndpointToken",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/events": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind Event",
      "operationId": "listManagementLoftShV1Event",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.EventList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Event",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/features": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind Feature",
      "operationId": "listManagementLoftShV1Feature",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.FeatureList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Feature",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/features/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Feature",
      "operationId": "readManagementLoftShV1Feature",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Feature"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Feature",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Feature",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/ingressauthtokens": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create an IngressAuthToken",
      "operationId": "createManagementLoftShV1IngressAuthToken",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.IngressAuthToken"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.IngressAuthToken"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.IngressAuthToken"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.IngressAuthToken"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "IngressAuthToken",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/kiosk/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Kiosk",
      "operationId": "readManagementLoftShV1Kiosk",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Kiosk"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Kiosk",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Kiosk",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/licenses/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified License",
      "operationId": "readManagementLoftShV1License",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.License"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "License",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the License",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/licenses/{name}/request": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the LicenseRequest",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create request of a License",
      "operationId": "createManagementLoftShV1LicenseRequest",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseRequest"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseRequest"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseRequest"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseRequest"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "LicenseRequest",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/licensetokens": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a LicenseToken",
      "operationId": "createManagementLoftShV1LicenseToken",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseToken"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseToken"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseToken"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LicenseToken"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "LicenseToken",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/loftupgrades": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a LoftUpgrade",
      "operationId": "createManagementLoftShV1LoftUpgrade",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LoftUpgrade"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LoftUpgrade"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LoftUpgrade"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.LoftUpgrade"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "LoftUpgrade",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of DevPodWorkspaceInstance",
      "operationId": "deleteManagementLoftShV1CollectionNamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind DevPodWorkspaceInstance",
      "operationId": "listManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a DevPodWorkspaceInstance",
      "operationId": "createManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a DevPodWorkspaceInstance",
      "operationId": "deleteManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified DevPodWorkspaceInstance",
      "operationId": "readManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified DevPodWorkspaceInstance",
      "operationId": "patchManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified DevPodWorkspaceInstance",
      "operationId": "replaceManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.DevPodWorkspaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}/delete": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "connect GET requests to delete of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1GetNamespacedDevPodWorkspaceInstanceDelete",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceDelete",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstanceDelete",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "options",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "connect POST requests to delete of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1PostNamespacedDevPodWorkspaceInstanceDelete",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceDelete",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}/getstatus": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "connect GET requests to getstatus of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1GetNamespacedDevPodWorkspaceInstanceGetstatus",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceGetStatus",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstanceGetStatus",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "options",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "connect POST requests to getstatus of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1PostNamespacedDevPodWorkspaceInstanceGetstatus",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceGetStatus",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}/ssh": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "connect GET requests to ssh of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1GetNamespacedDevPodWorkspaceInstanceSsh",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceSsh",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstanceSsh",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "options",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "connect POST requests to ssh of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1PostNamespacedDevPodWorkspaceInstanceSsh",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceSsh",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}/stop": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "connect GET requests to stop of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1GetNamespacedDevPodWorkspaceInstanceStop",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceStop",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstanceStop",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "options",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "connect POST requests to stop of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1PostNamespacedDevPodWorkspaceInstanceStop",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceStop",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/devpodworkspaceinstances/{name}/up": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "connect GET requests to up of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1GetNamespacedDevPodWorkspaceInstanceUp",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceUp",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the DevPodWorkspaceInstanceUp",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "options",
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "webMode",
        "type": "boolean",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "connect POST requests to up of DevPodWorkspaceInstance",
      "operationId": "connectManagementLoftShV1PostNamespacedDevPodWorkspaceInstanceUp",
      "produces": [
        "*/*"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "type": "string"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "connect",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstanceUp",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/projectsecrets": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of ProjectSecret",
      "operationId": "deleteManagementLoftShV1CollectionNamespacedProjectSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind ProjectSecret",
      "operationId": "listManagementLoftShV1NamespacedProjectSecret",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecretList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a ProjectSecret",
      "operationId": "createManagementLoftShV1NamespacedProjectSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/projectsecrets/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a ProjectSecret",
      "operationId": "deleteManagementLoftShV1NamespacedProjectSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified ProjectSecret",
      "operationId": "readManagementLoftShV1NamespacedProjectSecret",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ProjectSecret",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified ProjectSecret",
      "operationId": "patchManagementLoftShV1NamespacedProjectSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified ProjectSecret",
      "operationId": "replaceManagementLoftShV1NamespacedProjectSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/sharedsecrets": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind SharedSecret",
      "operationId": "listManagementLoftShV1NamespacedSharedSecret",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecretList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SharedSecret",
      "operationId": "createManagementLoftShV1NamespacedSharedSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/sharedsecrets/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a SharedSecret",
      "operationId": "deleteManagementLoftShV1NamespacedSharedSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified SharedSecret",
      "operationId": "readManagementLoftShV1NamespacedSharedSecret",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the SharedSecret",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified SharedSecret",
      "operationId": "patchManagementLoftShV1NamespacedSharedSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified SharedSecret",
      "operationId": "replaceManagementLoftShV1NamespacedSharedSecret",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecret"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/spaceinstances": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of SpaceInstance",
      "operationId": "deleteManagementLoftShV1CollectionNamespacedSpaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind SpaceInstance",
      "operationId": "listManagementLoftShV1NamespacedSpaceInstance",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SpaceInstance",
      "operationId": "createManagementLoftShV1NamespacedSpaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/spaceinstances/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a SpaceInstance",
      "operationId": "deleteManagementLoftShV1NamespacedSpaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified SpaceInstance",
      "operationId": "readManagementLoftShV1NamespacedSpaceInstance",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the SpaceInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified SpaceInstance",
      "operationId": "patchManagementLoftShV1NamespacedSpaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified SpaceInstance",
      "operationId": "replaceManagementLoftShV1NamespacedSpaceInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/virtualclusterinstances": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of VirtualClusterInstance",
      "operationId": "deleteManagementLoftShV1CollectionNamespacedVirtualClusterInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind VirtualClusterInstance",
      "operationId": "listManagementLoftShV1NamespacedVirtualClusterInstance",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a VirtualClusterInstance",
      "operationId": "createManagementLoftShV1NamespacedVirtualClusterInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/virtualclusterinstances/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a VirtualClusterInstance",
      "operationId": "deleteManagementLoftShV1NamespacedVirtualClusterInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified VirtualClusterInstance",
      "operationId": "readManagementLoftShV1NamespacedVirtualClusterInstance",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the VirtualClusterInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified VirtualClusterInstance",
      "operationId": "patchManagementLoftShV1NamespacedVirtualClusterInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified VirtualClusterInstance",
      "operationId": "replaceManagementLoftShV1NamespacedVirtualClusterInstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/virtualclusterinstances/{name}/kubeconfig": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the VirtualClusterInstanceKubeConfig",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create kubeconfig of a VirtualClusterInstance",
      "operationId": "createManagementLoftShV1NamespacedVirtualClusterInstanceKubeconfig",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceKubeConfig"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceKubeConfig"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceKubeConfig"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceKubeConfig"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstanceKubeConfig",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/virtualclusterinstances/{name}/log": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read log of the specified VirtualClusterInstance",
      "operationId": "readManagementLoftShV1NamespacedVirtualClusterInstanceLog",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceLog"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstanceLog",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "in": "query",
        "name": "container",
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "follow",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "insecureSkipTLSVerifyBackend",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "limitBytes",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the VirtualClusterInstanceLog",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "previous",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "sinceSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "tailLines",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "timestamps",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/namespaces/{namespace}/virtualclusterinstances/{name}/workloadkubeconfig": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read workloadkubeconfig of the specified VirtualClusterInstance",
      "operationId": "readManagementLoftShV1NamespacedVirtualClusterInstanceWorkloadkubeconfig",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceWorkloadKubeConfig"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstanceWorkloadKubeConfig",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the VirtualClusterInstanceWorkloadKubeConfig",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create workloadkubeconfig of a VirtualClusterInstance",
      "operationId": "createManagementLoftShV1NamespacedVirtualClusterInstanceWorkloadkubeconfig",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceWorkloadKubeConfig"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceWorkloadKubeConfig"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceWorkloadKubeConfig"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceWorkloadKubeConfig"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstanceWorkloadKubeConfig",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/ownedaccesskeys": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create an OwnedAccessKey",
      "operationId": "createManagementLoftShV1OwnedAccessKey",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "OwnedAccessKey",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/ownedaccesskeys/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete an OwnedAccessKey",
      "operationId": "deleteManagementLoftShV1OwnedAccessKey",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "OwnedAccessKey",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified OwnedAccessKey",
      "operationId": "readManagementLoftShV1OwnedAccessKey",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "OwnedAccessKey",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the OwnedAccessKey",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified OwnedAccessKey",
      "operationId": "patchManagementLoftShV1OwnedAccessKey",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "OwnedAccessKey",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified OwnedAccessKey",
      "operationId": "replaceManagementLoftShV1OwnedAccessKey",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.OwnedAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "OwnedAccessKey",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/policyviolations": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind PolicyViolation",
      "operationId": "listManagementLoftShV1PolicyViolation",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.PolicyViolationList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "PolicyViolation",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/projects": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of Project",
      "operationId": "deleteManagementLoftShV1CollectionProject",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind Project",
      "operationId": "listManagementLoftShV1Project",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Project",
      "operationId": "createManagementLoftShV1Project",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a Project",
      "operationId": "deleteManagementLoftShV1Project",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Project",
      "operationId": "readManagementLoftShV1Project",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Project",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified Project",
      "operationId": "patchManagementLoftShV1Project",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified Project",
      "operationId": "replaceManagementLoftShV1Project",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/chartinfo": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectChartInfo",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create chartinfo of a Project",
      "operationId": "createManagementLoftShV1ProjectChartinfo",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectChartInfo"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectChartInfo"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectChartInfo"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectChartInfo"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectChartInfo",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/charts": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read charts of the specified Project",
      "operationId": "readManagementLoftShV1ProjectCharts",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectCharts"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectCharts",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ProjectCharts",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/projects/{name}/clusters": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read clusters of the specified Project",
      "operationId": "readManagementLoftShV1ProjectClusters",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectClusters"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectClusters",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ProjectClusters",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/projects/{name}/importspace": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectImportSpace",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create importspace of a Project",
      "operationId": "createManagementLoftShV1ProjectImportspace",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportSpace"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportSpace"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportSpace"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportSpace"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectImportSpace",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/importvirtualcluster": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectImportVirtualCluster",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create importvirtualcluster of a Project",
      "operationId": "createManagementLoftShV1ProjectImportvirtualcluster",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportVirtualCluster"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportVirtualCluster"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportVirtualCluster"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectImportVirtualCluster"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectImportVirtualCluster",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/members": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read members of the specified Project",
      "operationId": "readManagementLoftShV1ProjectMembers",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMembers"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectMembers",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ProjectMembers",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/projects/{name}/migratespaceinstance": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectMigrateSpaceInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create migratespaceinstance of a Project",
      "operationId": "createManagementLoftShV1ProjectMigratespaceinstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateSpaceInstance"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateSpaceInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateSpaceInstance"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateSpaceInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectMigrateSpaceInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/migratevirtualclusterinstance": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectMigrateVirtualClusterInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create migratevirtualclusterinstance of a Project",
      "operationId": "createManagementLoftShV1ProjectMigratevirtualclusterinstance",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateVirtualClusterInstance"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateVirtualClusterInstance"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateVirtualClusterInstance"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectMigrateVirtualClusterInstance"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectMigrateVirtualClusterInstance",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/status": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read status of the specified Project",
      "operationId": "readManagementLoftShV1ProjectStatus",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Project",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update status of the specified Project",
      "operationId": "patchManagementLoftShV1ProjectStatus",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace status of the specified Project",
      "operationId": "replaceManagementLoftShV1ProjectStatus",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Project"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/projects/{name}/templates": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read templates of the specified Project",
      "operationId": "readManagementLoftShV1ProjectTemplates",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectTemplates"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectTemplates",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the ProjectTemplates",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/projectsecrets": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind ProjectSecret",
      "operationId": "listManagementLoftShV1ProjectSecretForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ProjectSecretList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/redirecttokens": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a RedirectToken",
      "operationId": "createManagementLoftShV1RedirectToken",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RedirectToken"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RedirectToken"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RedirectToken"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RedirectToken"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "RedirectToken",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/resetaccesskeys": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a ResetAccessKey",
      "operationId": "createManagementLoftShV1ResetAccessKey",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ResetAccessKey"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ResetAccessKey"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ResetAccessKey"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.ResetAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ResetAccessKey",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/runners": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of Runner",
      "operationId": "deleteManagementLoftShV1CollectionRunner",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind Runner",
      "operationId": "listManagementLoftShV1Runner",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RunnerList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Runner",
      "operationId": "createManagementLoftShV1Runner",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/runners/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a Runner",
      "operationId": "deleteManagementLoftShV1Runner",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Runner",
      "operationId": "readManagementLoftShV1Runner",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Runner",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified Runner",
      "operationId": "patchManagementLoftShV1Runner",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified Runner",
      "operationId": "replaceManagementLoftShV1Runner",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/runners/{name}/accesskey": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read accesskey of the specified Runner",
      "operationId": "readManagementLoftShV1RunnerAccesskey",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RunnerAccessKey"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "RunnerAccessKey",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the RunnerAccessKey",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/runners/{name}/config": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read config of the specified Runner",
      "operationId": "readManagementLoftShV1RunnerConfig",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.RunnerConfig"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "RunnerConfig",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the RunnerConfig",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/runners/{name}/status": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read status of the specified Runner",
      "operationId": "readManagementLoftShV1RunnerStatus",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Runner",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update status of the specified Runner",
      "operationId": "patchManagementLoftShV1RunnerStatus",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace status of the specified Runner",
      "operationId": "replaceManagementLoftShV1RunnerStatus",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Runner"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/selfsubjectaccessreviews": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SelfSubjectAccessReview",
      "operationId": "createManagementLoftShV1SelfSubjectAccessReview",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SelfSubjectAccessReview"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SelfSubjectAccessReview"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SelfSubjectAccessReview"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SelfSubjectAccessReview"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SelfSubjectAccessReview",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/selves": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Self",
      "operationId": "createManagementLoftShV1Self",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Self"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Self"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Self"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Self"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Self",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/selves/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Self",
      "operationId": "readManagementLoftShV1Self",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Self"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Self",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Self",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/sharedsecrets": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind SharedSecret",
      "operationId": "listManagementLoftShV1SharedSecretForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SharedSecretList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SharedSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/spaceconstraints": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of SpaceConstraint",
      "operationId": "deleteManagementLoftShV1CollectionSpaceConstraint",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind SpaceConstraint",
      "operationId": "listManagementLoftShV1SpaceConstraint",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraintList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SpaceConstraint",
      "operationId": "createManagementLoftShV1SpaceConstraint",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/spaceconstraints/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a SpaceConstraint",
      "operationId": "deleteManagementLoftShV1SpaceConstraint",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified SpaceConstraint",
      "operationId": "readManagementLoftShV1SpaceConstraint",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the SpaceConstraint",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified SpaceConstraint",
      "operationId": "patchManagementLoftShV1SpaceConstraint",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified SpaceConstraint",
      "operationId": "replaceManagementLoftShV1SpaceConstraint",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceConstraint"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/spaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind SpaceInstance",
      "operationId": "listManagementLoftShV1SpaceInstanceForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/spacetemplates": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of SpaceTemplate",
      "operationId": "deleteManagementLoftShV1CollectionSpaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind SpaceTemplate",
      "operationId": "listManagementLoftShV1SpaceTemplate",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplateList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SpaceTemplate",
      "operationId": "createManagementLoftShV1SpaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/spacetemplates/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a SpaceTemplate",
      "operationId": "deleteManagementLoftShV1SpaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified SpaceTemplate",
      "operationId": "readManagementLoftShV1SpaceTemplate",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the SpaceTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified SpaceTemplate",
      "operationId": "patchManagementLoftShV1SpaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified SpaceTemplate",
      "operationId": "replaceManagementLoftShV1SpaceTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SpaceTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/subjectaccessreviews": {
    "parameters": [
      {
        "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
        "in": "query",
        "name": "dryRun",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
        "in": "query",
        "name": "fieldManager",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
        "in": "query",
        "name": "fieldValidation",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a SubjectAccessReview",
      "operationId": "createManagementLoftShV1SubjectAccessReview",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SubjectAccessReview"
          }
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SubjectAccessReview"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SubjectAccessReview"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.SubjectAccessReview"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SubjectAccessReview",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/tasks": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of Task",
      "operationId": "deleteManagementLoftShV1CollectionTask",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind Task",
      "operationId": "listManagementLoftShV1Task",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.TaskList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Task",
      "operationId": "createManagementLoftShV1Task",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/tasks/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a Task",
      "operationId": "deleteManagementLoftShV1Task",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Task",
      "operationId": "readManagementLoftShV1Task",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Task",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified Task",
      "operationId": "patchManagementLoftShV1Task",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified Task",
      "operationId": "replaceManagementLoftShV1Task",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Task"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/tasks/{name}/log": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read log of the specified Task",
      "operationId": "readManagementLoftShV1TaskLog",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.TaskLog"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "TaskLog",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "in": "query",
        "name": "follow",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "insecureSkipTLSVerifyBackend",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "limitBytes",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the TaskLog",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "previous",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "sinceSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "tailLines",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "in": "query",
        "name": "timestamps",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/teams": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of Team",
      "operationId": "deleteManagementLoftShV1CollectionTeam",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind Team",
      "operationId": "listManagementLoftShV1Team",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.TeamList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a Team",
      "operationId": "createManagementLoftShV1Team",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/teams/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a Team",
      "operationId": "deleteManagementLoftShV1Team",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified Team",
      "operationId": "readManagementLoftShV1Team",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the Team",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified Team",
      "operationId": "patchManagementLoftShV1Team",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified Team",
      "operationId": "replaceManagementLoftShV1Team",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.Team"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/teams/{name}/accesskeys": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read accesskeys of the specified Team",
      "operationId": "readManagementLoftShV1TeamAccesskeys",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.TeamAccessKeys"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "TeamAccessKeys",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the TeamAccessKeys",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/teams/{name}/clusters": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read clusters of the specified Team",
      "operationId": "readManagementLoftShV1TeamClusters",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.TeamClusters"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "TeamClusters",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the TeamClusters",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/users": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of User",
      "operationId": "deleteManagementLoftShV1CollectionUser",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind User",
      "operationId": "listManagementLoftShV1User",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create an User",
      "operationId": "createManagementLoftShV1User",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/users/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete an User",
      "operationId": "deleteManagementLoftShV1User",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified User",
      "operationId": "readManagementLoftShV1User",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the User",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified User",
      "operationId": "patchManagementLoftShV1User",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified User",
      "operationId": "replaceManagementLoftShV1User",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.User"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/users/{name}/accesskeys": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read accesskeys of the specified User",
      "operationId": "readManagementLoftShV1UserAccesskeys",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserAccessKeys"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "UserAccessKeys",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the UserAccessKeys",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/users/{name}/clusters": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read clusters of the specified User",
      "operationId": "readManagementLoftShV1UserClusters",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserClusters"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "UserClusters",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the UserClusters",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/users/{name}/permissions": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read permissions of the specified User",
      "operationId": "readManagementLoftShV1UserPermissions",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserPermissions"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "UserPermissions",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the UserPermissions",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/users/{name}/profile": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read profile of the specified User",
      "operationId": "readManagementLoftShV1UserProfile",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserProfile"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "UserProfile",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the UserProfile",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create profile of an User",
      "operationId": "createManagementLoftShV1UserProfile",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserProfile"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserProfile"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserProfile"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.UserProfile"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "UserProfile",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/virtualclusterinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind VirtualClusterInstance",
      "operationId": "listManagementLoftShV1VirtualClusterInstanceForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterInstanceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/virtualclustertemplates": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete collection of VirtualClusterTemplate",
      "operationId": "deleteManagementLoftShV1CollectionVirtualClusterTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "deletecollection",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list or watch objects of kind VirtualClusterTemplate",
      "operationId": "listManagementLoftShV1VirtualClusterTemplate",
      "parameters": [
        {
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
          "in": "query",
          "name": "allowWatchBookmarks",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "in": "query",
          "name": "continue",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "in": "query",
          "name": "fieldSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "in": "query",
          "name": "labelSelector",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "in": "query",
          "name": "limit",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersion",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "in": "query",
          "name": "resourceVersionMatch",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
          "in": "query",
          "name": "sendInitialEvents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "in": "query",
          "name": "timeoutSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "in": "query",
          "name": "watch",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplateList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "post": {
      "consumes": [
        "*/*"
      ],
      "description": "create a VirtualClusterTemplate",
      "operationId": "createManagementLoftShV1VirtualClusterTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "post",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/virtualclustertemplates/{name}": {
    "delete": {
      "consumes": [
        "*/*"
      ],
      "description": "delete a VirtualClusterTemplate",
      "operationId": "deleteManagementLoftShV1VirtualClusterTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified VirtualClusterTemplate",
      "operationId": "readManagementLoftShV1VirtualClusterTemplate",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the VirtualClusterTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ],
    "patch": {
      "consumes": [
        "application/json-patch+json",
        "application/merge-patch+json",
        "application/strategic-merge-patch+json",
        "application/apply-patch+yaml"
      ],
      "description": "partially update the specified VirtualClusterTemplate",
      "operationId": "patchManagementLoftShV1VirtualClusterTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
          "in": "query",
          "name": "force",
          "type": "boolean",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "patch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "put": {
      "consumes": [
        "*/*"
      ],
      "description": "replace the specified VirtualClusterTemplate",
      "operationId": "replaceManagementLoftShV1VirtualClusterTemplate",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "required": true,
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
          "in": "query",
          "name": "fieldManager",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
          "in": "query",
          "name": "fieldValidation",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        },
        "201": {
          "description": "Created",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.management.v1.VirtualClusterTemplate"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "put",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    }
  },
  "/apis/management.loft.sh/v1/watch/apps": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of App. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1AppList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/apps/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind App. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1App",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "App",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the App",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusteraccesses": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of ClusterAccess. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1ClusterAccessList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusteraccesses/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind ClusterAccess. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1ClusterAccess",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterAccess",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the ClusterAccess",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusterroletemplates": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of ClusterRoleTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1ClusterRoleTemplateList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusterroletemplates/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind ClusterRoleTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1ClusterRoleTemplate",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ClusterRoleTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the ClusterRoleTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusters": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of Cluster. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1ClusterList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/clusters/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind Cluster. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1Cluster",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Cluster",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the Cluster",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/devpodworkspaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of DevPodWorkspaceInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1DevPodWorkspaceInstanceListForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/devpodworkspacetemplates": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of DevPodWorkspaceTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1DevPodWorkspaceTemplateList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/devpodworkspacetemplates/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind DevPodWorkspaceTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1DevPodWorkspaceTemplate",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the DevPodWorkspaceTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/devpodworkspaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of DevPodWorkspaceInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1NamespacedDevPodWorkspaceInstanceList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/devpodworkspaceinstances/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind DevPodWorkspaceInstance. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1NamespacedDevPodWorkspaceInstance",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "DevPodWorkspaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the DevPodWorkspaceInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/projectsecrets": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of ProjectSecret. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1NamespacedProjectSecretList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/projectsecrets/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind ProjectSecret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1NamespacedProjectSecret",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the ProjectSecret",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/spaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of SpaceInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1NamespacedSpaceInstanceList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/spaceinstances/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind SpaceInstance. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1NamespacedSpaceInstance",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the SpaceInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/virtualclusterinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of VirtualClusterInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1NamespacedVirtualClusterInstanceList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/namespaces/{namespace}/virtualclusterinstances/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind VirtualClusterInstance. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1NamespacedVirtualClusterInstance",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the VirtualClusterInstance",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/projects": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of Project. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1ProjectList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/projects/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind Project. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1Project",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Project",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the Project",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/projectsecrets": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of ProjectSecret. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1ProjectSecretListForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "ProjectSecret",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/runners": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of Runner. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1RunnerList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/runners/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind Runner. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1Runner",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Runner",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the Runner",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/spaceconstraints": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of SpaceConstraint. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1SpaceConstraintList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/spaceconstraints/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind SpaceConstraint. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1SpaceConstraint",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceConstraint",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the SpaceConstraint",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/spaceinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of SpaceInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1SpaceInstanceListForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/spacetemplates": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of SpaceTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1SpaceTemplateList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/spacetemplates/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind SpaceTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1SpaceTemplate",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "SpaceTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the SpaceTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/tasks": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of Task. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1TaskList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/tasks/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind Task. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1Task",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Task",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the Task",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/teams": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of Team. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1TeamList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/teams/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind Team. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1Team",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "Team",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the Team",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/users": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of User. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1UserList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/users/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind User. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1User",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "User",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the User",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/virtualclusterinstances": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of VirtualClusterInstance. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1VirtualClusterInstanceListForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterInstance",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/virtualclustertemplates": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch individual changes to a list of VirtualClusterTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "operationId": "watchManagementLoftShV1VirtualClusterTemplateList",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watchlist",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/management.loft.sh/v1/watch/virtualclustertemplates/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "watch changes to an object of kind VirtualClusterTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "operationId": "watchManagementLoftShV1VirtualClusterTemplate",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "managementLoftSh_v1"
      ],
      "x-kubernetes-action": "watch",
      "x-kubernetes-group-version-kind": {
        "group": "management.loft.sh",
        "kind": "VirtualClusterTemplate",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "name of the VirtualClusterTemplate",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/virtualcluster.loft.sh": {
    "get": {
      "consumes": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "description": "get information of a group",
      "operationId": "getVirtualclusterLoftShAPIGroup",
      "produces": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "virtualclusterLoftSh"
      ]
    }
  },
  "/apis/virtualcluster.loft.sh/v1": {
    "get": {
      "consumes": [
        "application/json",
        "application/yaml"
      ],
      "description": "get available resources",
      "operationId": "getVirtualclusterLoftShV1APIResources",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "virtualclusterLoftSh_v1"
      ]
    }
  },
  "/apis/virtualcluster.loft.sh/v1/helmreleases": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind HelmRelease",
      "operationId": "listVirtualclusterLoftShV1HelmReleaseForAllNamespaces",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.virtualcluster.v1.HelmReleaseList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "virtualclusterLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "virtualcluster.loft.sh",
        "kind": "HelmRelease",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/virtualcluster.loft.sh/v1/namespaces/{namespace}/helmreleases": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "list objects of kind HelmRelease",
      "operationId": "listVirtualclusterLoftShV1NamespacedHelmRelease",
      "produces": [
        "application/json",
        "application/yaml",
        "application/json;stream=watch"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.virtualcluster.v1.HelmReleaseList"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "virtualclusterLoftSh_v1"
      ],
      "x-kubernetes-action": "list",
      "x-kubernetes-group-version-kind": {
        "group": "virtualcluster.loft.sh",
        "kind": "HelmRelease",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
        "in": "query",
        "name": "allowWatchBookmarks",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
        "in": "query",
        "name": "continue",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
        "in": "query",
        "name": "fieldSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
        "in": "query",
        "name": "labelSelector",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
        "in": "query",
        "name": "limit",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersion",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
        "in": "query",
        "name": "resourceVersionMatch",
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
        "in": "query",
        "name": "sendInitialEvents",
        "type": "boolean",
        "uniqueItems": true
      },
      {
        "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
        "in": "query",
        "name": "timeoutSeconds",
        "type": "integer",
        "uniqueItems": true
      },
      {
        "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
        "in": "query",
        "name": "watch",
        "type": "boolean",
        "uniqueItems": true
      }
    ]
  },
  "/apis/virtualcluster.loft.sh/v1/namespaces/{namespace}/helmreleases/{name}": {
    "get": {
      "consumes": [
        "*/*"
      ],
      "description": "read the specified HelmRelease",
      "operationId": "readVirtualclusterLoftShV1NamespacedHelmRelease",
      "produces": [
        "application/json",
        "application/yaml"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/com.github.loft-sh.api.v3.pkg.apis.virtualcluster.v1.HelmRelease"
          }
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "virtualclusterLoftSh_v1"
      ],
      "x-kubernetes-action": "get",
      "x-kubernetes-group-version-kind": {
        "group": "virtualcluster.loft.sh",
        "kind": "HelmRelease",
        "version": "v1"
      }
    },
    "parameters": [
      {
        "description": "name of the HelmRelease",
        "in": "path",
        "name": "name",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "object name and auth scope, such as for teams and projects",
        "in": "path",
        "name": "namespace",
        "required": true,
        "type": "string",
        "uniqueItems": true
      },
      {
        "description": "If 'true', then the output is pretty printed.",
        "in": "query",
        "name": "pretty",
        "type": "string",
        "uniqueItems": true
      }
    ]
  }
}
